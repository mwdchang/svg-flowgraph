{
  "version": 3,
  "sources": ["../../../src/core/renderer.ts"],
  "sourcesContent": ["import * as d3 from 'd3';\nimport { EventEmitter } from './event-emitter';\nimport { removeChildren } from '../utils/dom-util';\nimport { traverseGraph, flattenGraph, getAStarPath } from './traverse';\nimport { pointOnPath, translate } from '../utils/svg-util';\n\nimport {\n  INode, IEdge, IGraph, IRect, IPoint,\n  D3Selection, D3SelectionIEdge, D3SelectionINode\n} from '../types';\n\ntype AsyncFunction <A,O> = (args: A) => Promise<O> \ntype LayoutFuncion <V, E> = AsyncFunction<IGraph<V, E>, IGraph<V, E>>;\n\ninterface Options {\n  el?: HTMLDivElement\n  runLayout: LayoutFuncion<any, any>\n  \n  useEdgeControl?: boolean\n  edgeControlOffsetType?: string\n  edgeControlOffset?: number\n\n  useZoom?: boolean\n  useMinimap?: boolean\n  useStableLayout?: boolean\n  useStableZoomPan?: boolean\n  useAStarRouting?: boolean\n}\n\nexport const pathFn = d3.line<{ x: number, y: number}>()\n  .x(d => d.x)\n  .y(d => d.y)\n  .curve(d3.curveBasis); // FIXME: temp hack\n\n\nexport abstract class Renderer<V, E> extends EventEmitter {\n  options: Options;\n  parentMap: Map<string, INode<V>>;\n  oldNodeMap: Map<string, IRect> = new Map();\n  oldEdgeMap: Map<string, { points: IPoint[] }> = new Map();\n\n  svgEl: SVGElement;\n  chart: D3Selection;\n  chartSize: { width: number, height: number } = { width: 1, height: 1 };\n\n  graph: IGraph<V, E> = null;\n\n  // misc\n  isGraphDirty: boolean = true; // Graph layout has changed\n  canLeverageStableLayout: boolean = false;\n\n  clickTimer: any;\n  zoom: d3.ZoomBehavior<Element, unknown>;\n  zoomTransformObject: d3.ZoomTransform = null;\n\n  constructor(options: Options) {\n    super(); // Event emitter\n    this.parentMap = new Map();\n    this.options = options;\n\n    if (this.options.el) {\n      this.initalize(this.options.el);\n    } else {\n      throw new Error('options must provide an element for graph rendering');\n    }\n  }\n\n  initalize(element: HTMLDivElement): void {\n    this.chartSize.width = element.clientWidth;\n    this.chartSize.height = element.clientHeight;\n    this.svgEl = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    this.svgEl.style.userSelect = 'none';\n    removeChildren(element).appendChild(this.svgEl);\n  }\n\n  async setData(graph: IGraph<V, E>): Promise<void> {\n    this.graph = graph;\n    this.calculateMaps();\n  }\n\n  calculateMaps(): void {\n    this.parentMap.clear();\n    traverseGraph(this.graph, node => {\n      if (node.nodes.length > 0) {\n        node.nodes.forEach(n => {\n          this.parentMap.set(n.id, node);\n        });\n      }\n    });\n  }\n\n  getBoundary(): { x1: number, y1: number, x2: number, y2: number } {\n    const t = d3.zoomTransform(this.chart.node() as Element);\n    const x1 = (0 - t.x) / t.k;\n    const y1 = (0 - t.y) / t.k;\n    const x2 = (this.chartSize.width) / t.k;\n    const y2 = (this.chartSize.height) / t.k;\n    return { x1, y1, x2, y2 };\n  }\n\n  createChartLayers(): void {\n    const { width, height } = this.chartSize;\n    const svg = d3.select(this.svgEl);\n    svg.selectAll('*').remove();\n    svg.attr('width', width + 'px');\n    svg.attr('height', height + 'px');\n    svg.append('defs');\n\n    svg.append('g').classed('background-layer', true);\n    svg.append('g').classed('data-layer', true);\n    svg.append('g').classed('foreground-layer', true);\n\n    // Add a nodes layer\n    svg.select('.data-layer').append('g').classed('nodes-layer', true);\n    this.chart = svg.select('.data-layer');\n  }\n\n  async render(): Promise<void> {\n    this.oldNodeMap.clear();\n    this.oldEdgeMap.clear();\n\n    if (this.chart && this.options.useStableLayout === true) {\n      this.chart.selectAll('.node').each((d :INode<V>) => {\n        this.oldNodeMap.set(d.id, {\n          x: d.x,\n          y: d.y,\n          width: d.width,\n          height: d.height\n        });\n      });\n      this.chart.selectAll('.edge').each((d :IEdge<E>) => {\n        this.oldEdgeMap.set(d.id, {\n          points: d.points\n        });\n      });\n    }\n\n    // Check if we need to re-run layout\n    if (this.isGraphDirty === true) {\n      console.log('Rerung layout');\n      this.graph = await this.options.runLayout(this.graph);\n      this.calculateMaps();\n    }\n\n    if (!this.chart) {\n      this.createChartLayers();\n    }\n\n    this.canLeverageStableLayout = this.stableLayoutCheck();\n\n    this.setupDefs();\n    this.setupNodes();\n    this.setupEdges();\n    if (this.options.useEdgeControl === true) {\n      this.setupEdgeControls();\n    }\n\n    // Enable various interactions and emitter events\n    this.chart.selectAll('.edge').call(this.enableEdgeInteraction, this);\n    this.chart.selectAll('.node-ui').call(this.enableNodeInteraction, this);\n    this.enableSVGInteraction(this);\n\n    // Enable dragging nodes\n    this.enableNodeDragging(this);\n\n    this.isGraphDirty = false;\n  }\n\n  updateEdgePoints(): void {\n    const chart = this.chart;\n    const options = this.options;\n    chart.selectAll('.edge').selectAll('path').attr('d', (d: IEdge<E>) => {\n      return pathFn(d.points);\n    });\n\n    if (options.useEdgeControl) {\n      chart.selectAll('.edge').each(function() {\n        const pathNode = d3.select(this).select('path').node() as SVGPathElement;\n        const controlPoint = pointOnPath(\n          pathNode,\n          options.edgeControlOffsetType,\n          options.edgeControlOffset);\n        d3.select(this).select('.edge-control')\n          .attr('transform', translate(controlPoint.x, controlPoint.y));\n      });\n    }\n  }\n\n\n  /**\n   * Edge interactions\n  */\n  enableEdgeInteraction(selection: D3Selection, renderer: Renderer<V, E>): void {\n    selection.each((_, edgeIndex: number, edges: SVGGElement[]) => {\n      const edge = d3.select(edges[edgeIndex]);\n      const emit = renderer.emit.bind(renderer);\n\n      edge.on('click', function(evt) {\n        evt.stopPropagation();\n        emit('edge-click', evt, d3.select(this), renderer);\n      });\n\n      edge.on('mouseenter', function(evt) {\n        evt.stopPropagation();\n        emit('edge-mouse-enter', evt, d3.select(this), renderer);\n      });\n\n      edge.on('mouseleave', function(evt) {\n        evt.stopPropagation();\n        emit('edge-mouse-leave', evt, d3.select(this), renderer);\n      });\n    });\n  }\n\n  /**\n   * Node interactions\n  */\n  enableNodeInteraction(selection: D3Selection, renderer: Renderer<V, E>): void {\n    selection.each((_, nodeIndex, nodes) => {\n      const node = d3.select(nodes[nodeIndex]);\n      const emit = renderer.emit.bind(renderer);\n\n      node.on('dblclick', function(evt) {\n        evt.stopPropagation();\n        window.clearTimeout(renderer.clickTimer);\n        emit('node-dbl-click', evt, d3.select(this), renderer);\n      });\n\n      node.on('click', function(evt) {\n        evt.stopPropagation();\n        const e = d3.select(this);\n        window.clearTimeout(renderer.clickTimer);\n        renderer.clickTimer = window.setTimeout(() => {\n          emit('node-click', evt, e, renderer);\n        }, 200);\n      });\n\n      node.on('mouseenter', function(evt) {\n        // Put the active element on top\n        const nodeElement = (node.node() as SVGGElement).parentNode;\n        const nodesContainer = nodeElement.parentNode;\n        nodesContainer.appendChild(nodeElement);\n\n        evt.stopPropagation();\n        emit('node-mouse-enter', evt, d3.select(this), renderer);\n      });\n\n      node.on('mouseleave', function(evt) {\n        evt.stopPropagation();\n        emit('node-mouse-leave', evt, d3.select(this), renderer);\n      });\n    });\n  }\n\n  /**\n   * Setup background/canvas interactions\n  */\n  enableSVGInteraction(renderer: Renderer<V, E>): void {\n    const chart = this.chart;\n    const emit = renderer.emit.bind(renderer);\n    const svg = d3.select(this.svgEl);\n    this.clickTimer = null;\n\n    svg.on('click', function (evt) {\n      evt.stopPropagation();\n      const pointerCoords = d3.zoomTransform(svg.node()).invert(d3.pointer(evt));\n      emit('background-click', evt, d3.select(this), renderer, {\n        x: pointerCoords[0],\n        y: pointerCoords[1]\n      });\n    });\n\n    svg.on('dblclick', function (evt) {\n      evt.stopPropagation();\n      const pointerCoords = d3.zoomTransform(svg.node()).invert(d3.pointer(evt));\n      emit('background-dbl-click', evt, d3.select(this), renderer, {\n        x: pointerCoords[0],\n        y: pointerCoords[1]\n      });\n    });\n\n    // Zoom control\n    // FIXME: evt type\n    const zoomed = (evt: any) =>  {\n      if (this.options.useZoom === false) return;\n      chart.attr('transform', evt.transform);\n    };\n    const zoomEnd = () => {\n      if (!this.graph) return;\n\n      this.zoomTransformObject = d3.zoomTransform(chart.node() as Element);\n\n      if (this.options.useMinimap === false || this.options.useZoom === false) return;\n      const { x1, y1, x2, y2 } = this.getBoundary();\n      const minimap = d3.select(this.svgEl).select('.foreground-layer').select('.minimap');\n      minimap.select('.current-view').remove();\n      minimap.append('rect')\n        .classed('current-view', true)\n        .attr('x', x1)\n        .attr('y', y1)\n        .attr('width', x2)\n        .attr('height', y2)\n        .attr('stroke', '#000')\n        .attr('stroke-width', 1)\n        .attr('fill', '#369')\n        .attr('fill-opacity', 0.1);\n    };\n\n    const minZoom = 0.05;\n    const maxZoom = Math.max(2, Math.floor(this.graph.width / this.chartSize.width));\n    let zoomLevel = Math.min(1, 1 / (this.graph.height / this.chartSize.height));\n    this.zoom = d3.zoom().scaleExtent([minZoom, maxZoom]).on('zoom', zoomed).on('end', zoomEnd);\n    svg.call(this.zoom).on('dblclick.zoom', null);\n\n    let zoomX = (-(this.graph.width * zoomLevel * 0.5) + 0.5 * this.chartSize.width) / zoomLevel;\n    let zoomY = (-(this.graph.height * zoomLevel * 0.5) + 0.5 * this.chartSize.height) / zoomLevel;\n\n    if (this.options.useStableZoomPan === true && this.zoomTransformObject !== null) {\n      zoomLevel = this.zoomTransformObject.k;\n      zoomX = this.zoomTransformObject.x / zoomLevel;\n      zoomY = this.zoomTransformObject.y / zoomLevel;\n    }\n    svg.call(\n      this.zoom.transform,\n      d3.zoomIdentity.translate(0, 0).scale(zoomLevel).translate(zoomX, zoomY)\n    );\n  }\n\n  setupEdgeControls(): void {\n    if (this.options.useEdgeControl === false) return;\n    const chart = this.chart;\n    const edges = chart.selectAll('.edge');\n    const options = this.options;\n    edges.selectAll('.edge-control').remove();\n    edges.each(function() {\n      const pathNode = d3.select(this).select('path').node() as SVGPathElement;\n      const controlPoint = pointOnPath(pathNode, options.edgeControlOffsetType, options.edgeControlOffset);\n      d3.select(this).append('g')\n        .classed('edge-control', true)\n        .attr('transform', translate(controlPoint.x, controlPoint.y));\n    });\n    chart.selectAll('.edge-control').call(this.renderEdgeControls);\n  }\n\n  /**\n   * FIXME: Just a simple count, need to handle hierarchies\n   * Try to keep layout stable across destructive actions where nodes/edges\n   * counts will be smaller than before\n   */\n  stableLayoutCheck(): boolean {\n    const chart = this.chart;\n    const options = this.options;\n    const flattened = flattenGraph(this.graph);\n    const numNodes = flattened.nodes.length - 1; // Exclude super parent\n    return options.useStableLayout && numNodes <= chart.selectAll('.node').size();\n  }\n\n  enableNodeDragging(renderer: Renderer<V, E>): void {\n    const options = this.options;\n    const edges = this.graph.edges;\n    const nodes = this.graph.nodes;\n    const updateEdgePoints = this.updateEdgePoints.bind(this);\n    const emitWrapper = renderer.emit.bind(renderer);\n    \n    let node: D3SelectionINode<V> = null;\n    let nodeDraggingIds: string[] = [];\n\n    let sufficientlyMoved = false;\n\n    function collisionFn(p: IPoint) {\n      const buffer = 10;\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        // FIXME: Thi is  a hack to get around hierarhical geometries, will need to\n        // relax this guard.\n        // if (node.nodes && node.nodes.length > 0) continue;\n        if (p.x >= node.x - buffer && p.x <= node.x + node.width + buffer) {\n          if (p.y >= node.y - buffer && p.y <= node.y + node.height + buffer) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    function nodeDragStart(evt: any): void  {\n      evt.sourceEvent.stopPropagation();\n\n      node = d3.select(this) as D3SelectionINode<V>;\n      const childrenNodes = node.selectAll('.node') as D3SelectionINode<V>;\n      nodeDraggingIds = [node.datum().label, ...childrenNodes.data().map(d => d.label)];\n\n      sufficientlyMoved = false;\n      emitWrapper('node-drag-start', evt, node, renderer);\n    }\n\n    function nodeDragMove(evt: any) {\n      const dx = evt.dx;\n      const dy = evt.dy;\n\n      sufficientlyMoved = true;\n\n      node.datum().x += dx;\n      node.datum().y += dy;\n      node.attr('transform', translate(node.datum().x, node.datum().y));\n\n\n      for (let i = 0; i < edges.length; i++) {\n        const edge = edges[i];\n        const source = edge.source;\n        const target = edge.target;\n\n        if (nodeDraggingIds.includes(source) && nodeDraggingIds.includes(target)) {\n          edge.points.forEach(p => {\n            p.x += dx;\n            p.y += dy;\n          });\n        } else if (nodeDraggingIds.includes(source)) {\n          edge.points[0].x += dx;\n          edge.points[0].y += dy;\n        } else if (nodeDraggingIds.includes(target)) {\n          edge.points[edge.points.length - 1].x += dx;\n          edge.points[edge.points.length - 1].y += dy;\n        }\n      }\n      updateEdgePoints();\n      emitWrapper('node-drag-move', evt, node, renderer);\n    }\n\n    function nodeDragEnd(evt: any): void {\n      // FIXME: Reroute edges\n      if (options.useAStarRouting && sufficientlyMoved) {\n        for (let i = 0; i < edges.length; i++) {\n          const edge = edges[i];\n          const source = edge.source;\n          const target = edge.target;\n\n          if (nodeDraggingIds.includes(source) || nodeDraggingIds.includes(target)) {\n            const points = edge.points;\n            const start = points[0];\n            const end = points[points.length - 1];\n            if (edge.source === edge.target) continue;\n            edge.points = getAStarPath(start, end, collisionFn, { w: 20, h: 20 });\n          }\n        }\n        updateEdgePoints();\n      }\n\n      // Clean up\n      nodeDraggingIds = [];\n      emitWrapper('node-drag-end', evt, node, renderer);\n    }\n\n    const nodeDrag = d3.drag()\n      .on('start', nodeDragStart)\n      .on('end', nodeDragEnd)\n      .on('drag', nodeDragMove);\n    this.chart.selectAll('.node').call(nodeDrag);\n  }\n\n  // Need to overide\n  /* eslint-disable */\n  renderEdgeControls(_selection: D3SelectionIEdge<E>): void {}\n\n  /* eslint-disable */\n  setupDefs(): void {}\n\n  // Need to implement\n  abstract setupNodes(): void\n  abstract setupEdges(): void\n}\n"],
  "mappings": "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",
  "names": []
}
