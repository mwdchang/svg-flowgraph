{
  "version": 3,
  "sources": ["../../../src/core/traverse.ts"],
  "sourcesContent": ["import { BinaryHeap } from '../utils/binary-heap';\nimport { IEdge, IGraph, INode, IPoint } from '../types';\n\nexport const traverseNode = <T>(node: INode<T>, callback: (node: INode<T>) => void ): void => {\n  callback(node);\n  for (let i = 0; i < node.nodes.length; i++) {\n    traverseNode(node.nodes[i], callback);\n  }\n};\n\nexport const traverseGraph = <V, E> (graph: IGraph<V, E>, callback: (node: INode<V>) => void): void => {\n  for (let i = 0; i < graph.nodes.length; i++) {\n    traverseNode(graph.nodes[i], callback);\n  }\n};\n\n/**\n * Returns a flat representation of all nodes and edges.\n */\nexport const flattenGraph = <V, E>(graph: IGraph<V, E>): { nodes: INode<V>[], edges: IEdge<E>[] } => {\n  let nodes: INode<V>[] = [];\n  traverseGraph(graph, (node) => {\n    nodes = nodes.concat(node);\n  });\n\n  return {\n    nodes,\n    edges: graph.edges\n  };\n};\n\n\n/**\n * AStar path find\n*/\ninterface IGrid {\n  w: number,\n  h: number\n}\ntype ColliderFn = (p: IPoint) => boolean\n\nexport const getAStarPath = (\n  start: IPoint,\n  goal: IPoint,\n  collider: ColliderFn,\n  gridCell: IGrid = { w: 10, h: 10 },\n  searchLimit = 7000\n): IPoint[] => {\n  // Encoding helpers\n  const PRIME = 756065179;\n  const SIZE = 8000;\n  const pAsKey = (p: IPoint): number => {\n    return (Math.round(p.x) + SIZE) * PRIME + (p.y + SIZE);\n  };\n  const keyAsP = (v: number): IPoint => {\n    const y = v % PRIME;\n    const x = (v - y) / PRIME;\n    return { x: x - SIZE, y: y - SIZE };\n  };\n\n  // Math helpers\n  const sqDifference = (a: number, b: number) => (a - b) * (a - b);\n  const sqDistance = (p1: IPoint, p2: IPoint) => {\n    return sqDifference(p1.x, p2.x) + sqDifference(p1.y, p2.y);\n  };\n\n  const heuristic = (p: IPoint) => sqDistance(p, goal) * 1.2;\n  const pEqual = (p1: IPoint, p2: IPoint) => p1.x === p2.x && p1.y === p2.y;\n\n  const nearestValue = (a: number, v: number) => Math.round(a / v) * v;\n  const nearestOnGrid = (a: IPoint) => ({ x: nearestValue(a.x, gridCell.w), y: nearestValue(a.y, gridCell.h) });\n  const startOnGrid = nearestOnGrid(start);\n  const goalOnGrid = nearestOnGrid(goal);\n\n  // AStar starts\n  if (pEqual(startOnGrid, goalOnGrid)) {\n    return [start, goal];\n  }\n\n  const cameFrom = [];\n  const gScore = {};\n  const fScore = {};\n  const heap = new BinaryHeap<number>(9999, (e) => {\n    return fScore[e];\n  });\n\n  const getNeighbours = (p: IPoint) => {\n    return [\n      // orthogonals\n      { x: p.x + gridCell.w, y: p.y },\n      { x: p.x - gridCell.w, y: p.y },\n      { x: p.x, y: p.y - gridCell.h },\n      { x: p.x, y: p.y + gridCell.h },\n\n      // diagonals\n      { x: p.x + gridCell.w, y: p.y + gridCell.h },\n      { x: p.x + gridCell.w, y: p.y - gridCell.h },\n      { x: p.x - gridCell.w, y: p.y - gridCell.h },\n      { x: p.x - gridCell.w, y: p.y + gridCell.h }\n    ];\n  };\n\n  // TOOD: consider replacing pAsKey/keyAsP/gScore/fScore with a js Map or something with a cleaner feeling interface\n  heap.insert(pAsKey(startOnGrid));\n  gScore[pAsKey(startOnGrid)] = 0;\n  fScore[pAsKey(startOnGrid)] = heuristic(startOnGrid);\n\n  let count = 0;\n  while (heap.size > 0) {\n    count = count + 1;\n    if (count > searchLimit) {\n      break;\n    }\n\n    const currentKey = heap.pop();\n    const current = keyAsP(currentKey);\n\n    const neighbours = getNeighbours(current);\n    // TODO: getJumpPoints used to be here but not anymore no one knows where it went, i guess it went home\n\n    for (let i = 0; i < neighbours.length; i++) {\n      const neighbour = neighbours[i];\n      const neighbourKey = pAsKey(neighbour);\n\n      if (pEqual(neighbour, goalOnGrid)) {\n        const path = [pAsKey(goal), currentKey];\n        while (cameFrom[path[path.length - 1]] !== undefined) {\n          path.push(cameFrom[path[path.length - 1]]);\n        }\n        path.push(pAsKey(start));\n        return path.map(keyAsP).reverse();\n      }\n\n      if (collider(neighbour)) continue;\n\n      const tentativeScore = gScore[pAsKey(current)] + sqDistance(current, neighbour);\n      if (gScore[neighbourKey] === undefined || tentativeScore < gScore[neighbourKey]) {\n        cameFrom[neighbourKey] = currentKey;\n        gScore[neighbourKey] = tentativeScore;\n        fScore[neighbourKey] = tentativeScore + heuristic(neighbour);\n        if (heap.data.indexOf(neighbourKey) === -1) {\n          heap.insert(neighbourKey);\n        }\n      }\n    }\n  }\n  return [start, goal];\n};\n"],
  "mappings": ";AAAA;AAGO,IAAM,eAAe,CAAI,MAAgB,aAA8C;AAC5F,WAAS;AACT,WAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,KAAK;AAC1C,iBAAa,KAAK,MAAM,IAAI;AAAA;AAAA;AAIzB,IAAM,gBAAgB,CAAQ,OAAqB,aAA6C;AACrG,WAAS,IAAI,GAAG,IAAI,MAAM,MAAM,QAAQ,KAAK;AAC3C,iBAAa,MAAM,MAAM,IAAI;AAAA;AAAA;AAO1B,IAAM,eAAe,CAAO,UAAkE;AACnG,MAAI,QAAoB;AACxB,gBAAc,OAAO,CAAC,SAAS;AAC7B,YAAQ,MAAM,OAAO;AAAA;AAGvB,SAAO;AAAA,IACL;AAAA,IACA,OAAO,MAAM;AAAA;AAAA;AAcV,IAAM,eAAe,CAC1B,OACA,MACA,UACA,WAAkB,EAAE,GAAG,IAAI,GAAG,MAC9B,cAAc,QACD;AAEb,QAAM,QAAQ;AACd,QAAM,OAAO;AACb,QAAM,SAAS,CAAC,MAAsB;AACpC,WAAQ,MAAK,MAAM,EAAE,KAAK,QAAQ,QAAS,GAAE,IAAI;AAAA;AAEnD,QAAM,SAAS,CAAC,MAAsB;AACpC,UAAM,IAAI,IAAI;AACd,UAAM,IAAK,KAAI,KAAK;AACpB,WAAO,EAAE,GAAG,IAAI,MAAM,GAAG,IAAI;AAAA;AAI/B,QAAM,eAAe,CAAC,GAAW,MAAe,KAAI,KAAM,KAAI;AAC9D,QAAM,aAAa,CAAC,IAAY,OAAe;AAC7C,WAAO,aAAa,GAAG,GAAG,GAAG,KAAK,aAAa,GAAG,GAAG,GAAG;AAAA;AAG1D,QAAM,YAAY,CAAC,MAAc,WAAW,GAAG,QAAQ;AACvD,QAAM,SAAS,CAAC,IAAY,OAAe,GAAG,MAAM,GAAG,KAAK,GAAG,MAAM,GAAG;AAExE,QAAM,eAAe,CAAC,GAAW,MAAc,KAAK,MAAM,IAAI,KAAK;AACnE,QAAM,gBAAgB,CAAC,MAAe,GAAE,GAAG,aAAa,EAAE,GAAG,SAAS,IAAI,GAAG,aAAa,EAAE,GAAG,SAAS;AACxG,QAAM,cAAc,cAAc;AAClC,QAAM,aAAa,cAAc;AAGjC,MAAI,OAAO,aAAa,aAAa;AACnC,WAAO,CAAC,OAAO;AAAA;AAGjB,QAAM,WAAW;AACjB,QAAM,SAAS;AACf,QAAM,SAAS;AACf,QAAM,OAAO,IAAI,WAAmB,MAAM,CAAC,MAAM;AAC/C,WAAO,OAAO;AAAA;AAGhB,QAAM,gBAAgB,CAAC,MAAc;AACnC,WAAO;AAAA,MAEL,EAAE,GAAG,EAAE,IAAI,SAAS,GAAG,GAAG,EAAE;AAAA,MAC5B,EAAE,GAAG,EAAE,IAAI,SAAS,GAAG,GAAG,EAAE;AAAA,MAC5B,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,IAAI,SAAS;AAAA,MAC5B,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE,IAAI,SAAS;AAAA,MAG5B,EAAE,GAAG,EAAE,IAAI,SAAS,GAAG,GAAG,EAAE,IAAI,SAAS;AAAA,MACzC,EAAE,GAAG,EAAE,IAAI,SAAS,GAAG,GAAG,EAAE,IAAI,SAAS;AAAA,MACzC,EAAE,GAAG,EAAE,IAAI,SAAS,GAAG,GAAG,EAAE,IAAI,SAAS;AAAA,MACzC,EAAE,GAAG,EAAE,IAAI,SAAS,GAAG,GAAG,EAAE,IAAI,SAAS;AAAA;AAAA;AAK7C,OAAK,OAAO,OAAO;AACnB,SAAO,OAAO,gBAAgB;AAC9B,SAAO,OAAO,gBAAgB,UAAU;AAExC,MAAI,QAAQ;AACZ,SAAO,KAAK,OAAO,GAAG;AACpB,YAAQ,QAAQ;AAChB,QAAI,QAAQ,aAAa;AACvB;AAAA;AAGF,UAAM,aAAa,KAAK;AACxB,UAAM,UAAU,OAAO;AAEvB,UAAM,aAAa,cAAc;AAGjC,aAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AAC1C,YAAM,YAAY,WAAW;AAC7B,YAAM,eAAe,OAAO;AAE5B,UAAI,OAAO,WAAW,aAAa;AACjC,cAAM,OAAO,CAAC,OAAO,OAAO;AAC5B,eAAO,SAAS,KAAK,KAAK,SAAS,QAAQ,QAAW;AACpD,eAAK,KAAK,SAAS,KAAK,KAAK,SAAS;AAAA;AAExC,aAAK,KAAK,OAAO;AACjB,eAAO,KAAK,IAAI,QAAQ;AAAA;AAG1B,UAAI,SAAS;AAAY;AAEzB,YAAM,iBAAiB,OAAO,OAAO,YAAY,WAAW,SAAS;AACrE,UAAI,OAAO,kBAAkB,UAAa,iBAAiB,OAAO,eAAe;AAC/E,iBAAS,gBAAgB;AACzB,eAAO,gBAAgB;AACvB,eAAO,gBAAgB,iBAAiB,UAAU;AAClD,YAAI,KAAK,KAAK,QAAQ,kBAAkB,IAAI;AAC1C,eAAK,OAAO;AAAA;AAAA;AAAA;AAAA;AAKpB,SAAO,CAAC,OAAO;AAAA;",
  "names": []
}
