{
  "version": 3,
  "sources": ["../../../src/fn/group.ts"],
  "sourcesContent": ["import _ from 'lodash';\nimport { Renderer } from '../core';\nimport { INode } from '../types';\nimport { flattenGraph } from '../core/traverse';\n\nexport const group = <V, E>(\n  G: Renderer<V, E>,\n  groupName: string,\n  nodeIds: string[]\n): void => {\n  // 0) check parent\n  const nodesData = flattenGraph(G.graph).nodes.filter(d => nodeIds.includes(d.id));\n\n  const parentId = (id: string): string => {\n    if (G.parentMap.has(id)) {\n      return G.parentMap.get(id).id;\n    }\n    return '';\n  };\n\n  if (_.uniq(nodesData.map(d => parentId(d.id))).length !== 1) {\n    console.log('Cannot group across different levels');\n    return;\n  }\n\n  const groupNode: INode<V> = {\n    id: groupName,\n    label: groupName,\n    type: 'custom',\n    nodes: [],\n    data: null,\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n\n\n  if (G.parentMap.has(nodesData[0].id)) {\n    // 1) Move nodes to new group\n    const parentData = G.parentMap.get(nodesData[0].id);\n    nodeIds.forEach(nodeId => {\n      const temp = _.remove(parentData.nodes, (node: INode<V>) => node.id === nodeId)[0];\n\n      // Need to create a new node wrapper to avoid double pointers problem\n      const newNode = { ...temp };\n      groupNode.nodes.push(newNode);\n    });\n\n    // 2) Add new gruop node\n    parentData.nodes.push(groupNode);\n  } else { // Top level\n    // 1) Move nodes to new group\n    nodeIds.forEach(nodeId => {\n      const temp = _.remove(G.graph.nodes, (node: INode<V>) => node.id === nodeId)[0];\n\n      // Need to create a new node wrapper to avoid double pointers problem\n      const newNode = { ...temp };\n      groupNode.nodes.push(newNode);\n    });\n\n    // 2) Add new gruop node\n    G.graph.nodes.push(groupNode);\n  }\n  G.isGraphDirty = true;\n};\n\nexport const ungroup = <V, E>(\n  G: Renderer<V, E>,\n  groupName: string\n): void => {\n  const groupData = flattenGraph(G.graph).nodes.filter(d => d.id === groupName)[0];\n\n  if (G.parentMap.has(groupName)) {\n    const parentData = G.parentMap.get(groupName);\n    // 0) Remove group\n    _.remove(parentData.nodes, n => n.id === groupName);\n\n    // 1) Add group children back into group parent\n    groupData.nodes.forEach(node => {\n      const temp = { ...node };\n      parentData.nodes.push(temp);\n    });\n  } else {\n    _.remove(G.graph.nodes, n => n.id === groupName);\n    groupData.nodes.forEach(node => {\n      const temp = { ...node };\n      G.graph.nodes.push(temp);\n    });\n  }\n  delete groupData.nodes;\n  G.isGraphDirty = true;\n};\n"],
  "mappings": ";AAAA;AAGA;AAEO,IAAM,QAAQ,CACnB,GACA,WACA,YACS;AAET,QAAM,YAAY,aAAa,EAAE,OAAO,MAAM,OAAO,OAAK,QAAQ,SAAS,EAAE;AAE7E,QAAM,WAAW,CAAC,OAAuB;AACvC,QAAI,EAAE,UAAU,IAAI,KAAK;AACvB,aAAO,EAAE,UAAU,IAAI,IAAI;AAAA;AAE7B,WAAO;AAAA;AAGT,MAAI,EAAE,KAAK,UAAU,IAAI,OAAK,SAAS,EAAE,MAAM,WAAW,GAAG;AAC3D,YAAQ,IAAI;AACZ;AAAA;AAGF,QAAM,YAAsB;AAAA,IAC1B,IAAI;AAAA,IACJ,OAAO;AAAA,IACP,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM;AAAA,IACN,GAAG;AAAA,IACH,GAAG;AAAA,IACH,OAAO;AAAA,IACP,QAAQ;AAAA;AAIV,MAAI,EAAE,UAAU,IAAI,UAAU,GAAG,KAAK;AAEpC,UAAM,aAAa,EAAE,UAAU,IAAI,UAAU,GAAG;AAChD,YAAQ,QAAQ,YAAU;AACxB,YAAM,OAAO,EAAE,OAAO,WAAW,OAAO,CAAC,SAAmB,KAAK,OAAO,QAAQ;AAGhF,YAAM,UAAU,KAAK;AACrB,gBAAU,MAAM,KAAK;AAAA;AAIvB,eAAW,MAAM,KAAK;AAAA,SACjB;AAEL,YAAQ,QAAQ,YAAU;AACxB,YAAM,OAAO,EAAE,OAAO,EAAE,MAAM,OAAO,CAAC,SAAmB,KAAK,OAAO,QAAQ;AAG7E,YAAM,UAAU,KAAK;AACrB,gBAAU,MAAM,KAAK;AAAA;AAIvB,MAAE,MAAM,MAAM,KAAK;AAAA;AAErB,IAAE,eAAe;AAAA;AAGZ,IAAM,UAAU,CACrB,GACA,cACS;AACT,QAAM,YAAY,aAAa,EAAE,OAAO,MAAM,OAAO,OAAK,EAAE,OAAO,WAAW;AAE9E,MAAI,EAAE,UAAU,IAAI,YAAY;AAC9B,UAAM,aAAa,EAAE,UAAU,IAAI;AAEnC,MAAE,OAAO,WAAW,OAAO,OAAK,EAAE,OAAO;AAGzC,cAAU,MAAM,QAAQ,UAAQ;AAC9B,YAAM,OAAO,KAAK;AAClB,iBAAW,MAAM,KAAK;AAAA;AAAA,SAEnB;AACL,MAAE,OAAO,EAAE,MAAM,OAAO,OAAK,EAAE,OAAO;AACtC,cAAU,MAAM,QAAQ,UAAQ;AAC9B,YAAM,OAAO,KAAK;AAClB,QAAE,MAAM,MAAM,KAAK;AAAA;AAAA;AAGvB,SAAO,UAAU;AACjB,IAAE,eAAe;AAAA;",
  "names": []
}
