{
  "version": 3,
  "sources": ["../../../src/fn/highlight.ts"],
  "sourcesContent": ["import * as d3 from 'd3';\nimport _ from 'lodash';\nimport { Renderer } from '../core';\nimport { INode, IEdge } from '../types';\n\ninterface HighlightOptions {\n  color?: string;\n  duration?: number;\n}\n\nexport const highlight = <V, E>(\n  G: Renderer<V, E>,\n  nodes: string[], \n  edges: { source: string, target: string }[],\n  options: HighlightOptions\n): string => {\n  const svg = d3.select(G.svgEl);\n  const chart = G.chart;\n\n  const color = options.color || 'red';\n  const duration = options.duration || 2000;\n\n  const highlightId = `glow${(new Date()).getTime()}`;\n\n  // Add temporary filter definition\n  const filter = svg.select('defs')\n    .append('filter')\n    .attr('id', highlightId)\n    .attr('width', '200%')\n    .attr('filterUnits', 'userSpaceOnUse');\n\n  filter.append('feGaussianBlur')\n    .attr('stdDeviation', 4.5)\n    .attr('result', 'blur');\n\n  filter.append('feOffset')\n    .attr('in', 'blur')\n    .attr('result', 'offsetBlur')\n    .attr('dx', 0)\n    .attr('dy', 0)\n    .attr('x', -10)\n    .attr('y', -10);\n\n  filter.append('feFlood')\n    .attr('in', 'offsetBlur')\n    .attr('flood-color', color)\n    .attr('flood-opacity', 0.95)\n    .attr('result', 'offsetColor');\n\n  filter.append('feComposite')\n    .attr('in', 'offsetColor')\n    .attr('in2', 'offsetBlur')\n    .attr('operator', 'in')\n    .attr('result', 'offsetBlur');\n\n\n  const feMerge = filter.append('feMerge');\n  feMerge.append('feMergeNode')\n    .attr('in', 'offsetBlur');\n\n  feMerge.append('feMergeNode')\n    .attr('in', 'SourceGraphic');\n\n  // Apply filter\n  // FIXME: not very efficient\n  const hNodes = chart.selectAll('.node').filter((d: INode<V>) => { return nodes.includes(d.id); });\n  hNodes.style('filter', `url(#${highlightId})`).classed(`${highlightId}`, true);\n\n  const hEdges = chart.selectAll('.edge').filter((d: IEdge<E>) => {\n    return _.some(edges, edge => edge.source === d.source && edge.target === d.target);\n  });\n  hEdges.style('filter', `url(#${highlightId})`).classed(`${highlightId}`, true);\n\n  if (duration > 0) {\n    svg.select(`#${highlightId}`).select('feGaussianBlur')\n      .transition()\n      .duration(duration)\n      .attr('stdDeviation', 0.1) // Set to 0 create a weird flashing effect\n      .on('end', () => {\n        hNodes.style('filter', null);\n        hEdges.style('filter', null);\n        svg.select(`#${highlightId}`).remove();\n      });\n  }\n  return highlightId;\n};\n\n// Short cuts\nexport const highlightNode = <V, E>(G:Renderer<V, E>, id: string, options: HighlightOptions): string => {\n  return highlight(G, [id], [], options);\n};\n\n"],
  "mappings": ";AAAA;AAAA;AAAA;AACA;AASO,IAAM,YAAY,CACvB,GACA,OACA,OACA,YACW;AACX,QAAM,MAAM,AAAG,OAAO,EAAE;AACxB,QAAM,QAAQ,EAAE;AAEhB,QAAM,QAAQ,QAAQ,SAAS;AAC/B,QAAM,WAAW,QAAQ,YAAY;AAErC,QAAM,cAAc,OAAQ,IAAI,OAAQ;AAGxC,QAAM,SAAS,IAAI,OAAO,QACvB,OAAO,UACP,KAAK,MAAM,aACX,KAAK,SAAS,QACd,KAAK,eAAe;AAEvB,SAAO,OAAO,kBACX,KAAK,gBAAgB,KACrB,KAAK,UAAU;AAElB,SAAO,OAAO,YACX,KAAK,MAAM,QACX,KAAK,UAAU,cACf,KAAK,MAAM,GACX,KAAK,MAAM,GACX,KAAK,KAAK,KACV,KAAK,KAAK;AAEb,SAAO,OAAO,WACX,KAAK,MAAM,cACX,KAAK,eAAe,OACpB,KAAK,iBAAiB,MACtB,KAAK,UAAU;AAElB,SAAO,OAAO,eACX,KAAK,MAAM,eACX,KAAK,OAAO,cACZ,KAAK,YAAY,MACjB,KAAK,UAAU;AAGlB,QAAM,UAAU,OAAO,OAAO;AAC9B,UAAQ,OAAO,eACZ,KAAK,MAAM;AAEd,UAAQ,OAAO,eACZ,KAAK,MAAM;AAId,QAAM,SAAS,MAAM,UAAU,SAAS,OAAO,CAAC,MAAgB;AAAE,WAAO,MAAM,SAAS,EAAE;AAAA;AAC1F,SAAO,MAAM,UAAU,QAAQ,gBAAgB,QAAQ,GAAG,eAAe;AAEzE,QAAM,SAAS,MAAM,UAAU,SAAS,OAAO,CAAC,MAAgB;AAC9D,WAAO,EAAE,KAAK,OAAO,UAAQ,KAAK,WAAW,EAAE,UAAU,KAAK,WAAW,EAAE;AAAA;AAE7E,SAAO,MAAM,UAAU,QAAQ,gBAAgB,QAAQ,GAAG,eAAe;AAEzE,MAAI,WAAW,GAAG;AAChB,QAAI,OAAO,IAAI,eAAe,OAAO,kBAClC,aACA,SAAS,UACT,KAAK,gBAAgB,KACrB,GAAG,OAAO,MAAM;AACf,aAAO,MAAM,UAAU;AACvB,aAAO,MAAM,UAAU;AACvB,UAAI,OAAO,IAAI,eAAe;AAAA;AAAA;AAGpC,SAAO;AAAA;AAIF,IAAM,gBAAgB,CAAO,GAAkB,IAAY,YAAsC;AACtG,SAAO,UAAU,GAAG,CAAC,KAAK,IAAI;AAAA;",
  "names": []
}
