{
  "version": 3,
  "sources": ["../../../src/utils/simplify.ts"],
  "sourcesContent": ["import { IPoint } from '../types';\n\nconst simplifyDPStep = (\n  points: IPoint[], \n  first: number, \n  last: number, \n  sqTolerance: number, \n  simplified: IPoint[]\n) => {\n  const sqSegmentDistance = (p: IPoint, p1: IPoint, p2: IPoint) => {\n    const sqDifference = (a: number, b: number) => (a - b) * (a - b);\n    const sqDistance = (p1: IPoint, p2: IPoint) => sqDifference(p1.x, p2.x) + sqDifference(p1.y, p2.y);\n\n    if (p1.x === p2.x && p1.y === p2.y) return sqDistance(p, p1);\n\n    const t = ((p.x - p1.x) * (p2.x - p1.x) + (p.y - p1.y) * (p2.y - p1.y)) / sqDistance(p2, p1);\n    if (t > 1) return sqDistance(p, p2);\n    else if (t > 0) return sqDistance(p, { x: p1.x + (p2.x - p1.x) * t, y: p1.y + (p2.y - p1.y) * t });\n    else return sqDistance(p, p1);\n  };\n\n  let maxSqDist = sqTolerance;\n  let index = -1;\n\n  for (let i = first + 1; i < last; i++) {\n    const sqDist = sqSegmentDistance(points[i], points[first], points[last]);\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n    simplified.push(points[index]);\n    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n  }\n};\n\nconst simplifyDouglasPeucker = (points: IPoint[], sqTolerance: number) => {\n  const last = points.length - 1;\n  const simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n  return simplified;\n};\n\n/**\n * Ramer-Douglas-Peucker shape simplification algorithm\n * https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\n */\nexport const simplifyPath = (points: IPoint[], tolerance = 8.0): IPoint[] => {\n  if (points.length <= 2) return points;\n  return simplifyDouglasPeucker(points, tolerance * tolerance);\n};\n\n// Add ponts along a path\n// export const addPoints = (path, minDistance = 10.0) => {\n//   const distance = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);\n//   const pointsalong = (a, b, n) => Array.from(Array(n + 2), (_, i) => ({ x: (b.x - a.x) * (i / (n + 1)) + a.x, y: (b.y - a.y) * (i / (n + 1)) + a.y }));\n//   const slidingwindow = (arr, n, func) => arr.slice(0, arr.length - n + 1).map((_, i) => func(arr.slice(i, i + n)));\n// \n//   return [].concat(...slidingwindow(path, 2, (pair) => {\n//     if (distance(pair[0], pair[1]) < minDistance) {\n//       return [pair[0]];\n//     } else {\n//       return pointsalong(pair[0], pair[1], Math.floor(distance(pair[0], pair[1]) / minDistance));\n//     };\n//   }), [path[path.length - 1]]);\n// };\n\n"],
  "mappings": ";AAEA,IAAM,iBAAiB,CACrB,QACA,OACA,MACA,aACA,eACG;AACH,QAAM,oBAAoB,CAAC,GAAW,IAAY,OAAe;AAC/D,UAAM,eAAe,CAAC,GAAW,MAAe,KAAI,KAAM,KAAI;AAC9D,UAAM,aAAa,CAAC,KAAY,QAAe,aAAa,IAAG,GAAG,IAAG,KAAK,aAAa,IAAG,GAAG,IAAG;AAEhG,QAAI,GAAG,MAAM,GAAG,KAAK,GAAG,MAAM,GAAG;AAAG,aAAO,WAAW,GAAG;AAEzD,UAAM,IAAM,IAAE,IAAI,GAAG,KAAM,IAAG,IAAI,GAAG,KAAM,GAAE,IAAI,GAAG,KAAM,IAAG,IAAI,GAAG,MAAM,WAAW,IAAI;AACzF,QAAI,IAAI;AAAG,aAAO,WAAW,GAAG;AAAA,aACvB,IAAI;AAAG,aAAO,WAAW,GAAG,EAAE,GAAG,GAAG,IAAK,IAAG,IAAI,GAAG,KAAK,GAAG,GAAG,GAAG,IAAK,IAAG,IAAI,GAAG,KAAK;AAAA;AACzF,aAAO,WAAW,GAAG;AAAA;AAG5B,MAAI,YAAY;AAChB,MAAI,QAAQ;AAEZ,WAAS,IAAI,QAAQ,GAAG,IAAI,MAAM,KAAK;AACrC,UAAM,SAAS,kBAAkB,OAAO,IAAI,OAAO,QAAQ,OAAO;AAClE,QAAI,SAAS,WAAW;AACtB,cAAQ;AACR,kBAAY;AAAA;AAAA;AAIhB,MAAI,YAAY,aAAa;AAC3B,QAAI,QAAQ,QAAQ;AAAG,qBAAe,QAAQ,OAAO,OAAO,aAAa;AACzE,eAAW,KAAK,OAAO;AACvB,QAAI,OAAO,QAAQ;AAAG,qBAAe,QAAQ,OAAO,MAAM,aAAa;AAAA;AAAA;AAI3E,IAAM,yBAAyB,CAAC,QAAkB,gBAAwB;AACxE,QAAM,OAAO,OAAO,SAAS;AAC7B,QAAM,aAAa,CAAC,OAAO;AAC3B,iBAAe,QAAQ,GAAG,MAAM,aAAa;AAC7C,aAAW,KAAK,OAAO;AACvB,SAAO;AAAA;AAOF,IAAM,eAAe,CAAC,QAAkB,YAAY,MAAkB;AAC3E,MAAI,OAAO,UAAU;AAAG,WAAO;AAC/B,SAAO,uBAAuB,QAAQ,YAAY;AAAA;",
  "names": []
}
